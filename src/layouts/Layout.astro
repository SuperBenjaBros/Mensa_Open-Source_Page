---
import "../styles/global.css"
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />

		<title>{"Mensa"}{Astro.props.title}</title>

		<meta name="author" content="SuperBenjaBros" />

		<link rel="icon" type="image/svg+xml" href="favicon.svg" />

		<meta name="description" content={ `${Astro.props.description}` } />

		<meta property="og:type" content="website" />
		<meta property="og:image" content="https://superbenjabros.github.io/Mensa_Open-Source_Page/Banner.webp" />
		<meta property="og:image:width"  content="1200">
    	<meta property="og:image:height" content="630">

		<meta name="twitter:card" content="summary_large_image" />

		<link rel="canonical" href="https://superbenjabros.github.io/Mensa_Open-Source_Page" />

		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

		<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=block" rel="stylesheet" />

        <script>
            (() => {
                const DEPTH = 350;
                const EDGE_PAD = 8;
                const nodes = document.querySelectorAll('.MouseEffect');

                for (const el of nodes) {
                    if (!(el instanceof HTMLElement) || el.dataset.meInit) continue;

                    el.dataset.meInit = '1';
                    el.style.transformStyle = 'preserve-3d';

                    let raf = null;
                    let leaveTimer = null;
                    let disableTransTimer = null;
                    let rx = 0, ry = 0;

                    const getTimeMs = () => {
                        const t = getComputedStyle(el).getPropertyValue('--TimeMouseEffect') || '.2s';
                        const m = t.match(/([\d.]+)(ms|s)?/);
                        if (!m) return 200;
                        const v = parseFloat(m[1]);
                        return (m[2] === 'ms' ? v : v * 1000);
                    };

                    const parsePerspective = () => {
                        const p = getComputedStyle(el).getPropertyValue('--Perspective') || '8';
                        const v = parseFloat(p);
                        return isNaN(v) ? 8 : Math.abs(v);
                    };

                    const apply = () => {
                        raf = null;
                        el.style.transform = `perspective(${DEPTH}px) rotateX(${rx}deg) rotateY(${ry}deg)`;
                    };

                    const scheduleTransition = () => {
                        if (disableTransTimer) clearTimeout(disableTransTimer);
                        el.style.transition = `transform ${getTimeMs()}ms ease-in-out`;
                        disableTransTimer = setTimeout(() => {
                            el.style.transition = 'transform 0s';
                        }, getTimeMs());
                    };

                    const onmove = e => {
                        if (leaveTimer) { clearTimeout(leaveTimer); leaveTimer = null; }

                        const point = ('touches' in e) ? e.touches[0] : e;
                        const r = el.getBoundingClientRect();
                        
                        const cx = r.left + r.width / 2;
                        const cy = r.top + r.height / 2;
                        
                        const nx = Math.max(-1, Math.min(1, (point.clientX - cx) / (r.width / 2)));
                        const ny = Math.max(-1, Math.min(1, (point.clientY - cy) / (r.height / 2)));

                        const mag = parsePerspective();
                        rx = -ny * mag;
                        ry = nx * mag;

                        if (raf === null) raf = requestAnimationFrame(apply);
                    };

                    const onenter = () => {
                        scheduleTransition();
                    };

                    const onleave = () => {
                        if (leaveTimer) { clearTimeout(leaveTimer); leaveTimer = null; }
                        if (disableTransTimer) { clearTimeout(disableTransTimer); disableTransTimer = null; }
                        if (raf !== null) { cancelAnimationFrame(raf); raf = null; }

                        rx = 0;
                        ry = 0;
                        scheduleTransition();
                        apply();
                    };

                    const ondown = e => {
                        onenter();
                        
                        const onDocumentMove = evt => {
                            onmove(evt);
                        };
                        
                        const onDocumentUp = () => {
                            onleave();
                            window.removeEventListener('pointermove', onDocumentMove);
                            window.removeEventListener('pointerup', onDocumentUp);
                        };

                        window.addEventListener('pointermove', onDocumentMove);
                        window.addEventListener('pointerup', onDocumentUp);
                    };

                    el.addEventListener('pointerdown', ondown);
                    el.addEventListener('pointerenter', onenter);
                    el.addEventListener('pointermove', onmove);
                    el.addEventListener('pointerleave', onleave);
                }
            })();
        </script>

	</head>
	<body>
		<slot />
	</body>
</html>

<style>
	html,
	body {
		margin: 0;
		width: 100%;
		height: 100%;
	}
</style>
