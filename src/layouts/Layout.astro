---
import "../styles/global.css"
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />

		<title>{"Mensa"}{Astro.props.title}</title>

		<meta name="author" content="SuperBenjaBros" />

		<link rel="icon" type="image/svg+xml" href="favicon.svg" />

		<meta name="description" content={ `${Astro.props.description}` } />

		<meta property="og:type" content="website" />
		<meta property="og:image" content="https://superbenjabros.github.io/Mensa_Open-Source_Page/Banner.webp" />
		<meta property="og:image:width"  content="1200">
    	<meta property="og:image:height" content="630">

		<meta name="twitter:card" content="summary_large_image" />

		<link rel="canonical" href="https://superbenjabros.github.io/Mensa_Open-Source_Page" />

		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

		<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=block" rel="stylesheet" />

<script>
(() => {
    const DEPTH = 350;
    const nodes = Array.from(document.querySelectorAll('.MouseEffect')).filter(n => n instanceof HTMLElement);
    if (!nodes.length) return;
    const state = new WeakMap();

    const getTimeMs = el => {
        const t = getComputedStyle(el).getPropertyValue('--TimeMouseEffect') || '.2s';
        const m = t.match(/([\d.]+)(ms|s)?/);
        if (!m) return 200;
        const v = parseFloat(m[1]);
        return (m[2] === 'ms' ? v : v * 1000);
    };

    const parsePerspective = el => {
        const p = getComputedStyle(el).getPropertyValue('--Perspective') || '8';
        const v = parseFloat(p);
        return isNaN(v) ? 8 : Math.abs(v);
    };

    for (const el of nodes) {
        el.style.transformStyle = 'preserve-3d';
        state.set(el, { raf: null, rx: 0, ry: 0, active: false, disableTransTimer: null });
    }

    const apply = el => {
        const s = state.get(el);
        s.raf = null;
        el.style.transform = `perspective(${DEPTH}px) rotateX(${s.rx}deg) rotateY(${s.ry}deg)`;
    };

    const scheduleTransition = el => {
        const s = state.get(el);
        if (s.disableTransTimer) clearTimeout(s.disableTransTimer);
        el.style.transition = `transform ${getTimeMs(el)}ms ease-in-out`;
        s.disableTransTimer = setTimeout(() => el.style.transition = 'transform 0s', getTimeMs(el));
    };

    const computeFor = (el, point) => {
        const s = state.get(el);
        const r = el.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top + r.height / 2;
        const nx = Math.max(-1, Math.min(1, (point.clientX - cx) / (r.width / 2)));
        const ny = Math.max(-1, Math.min(1, (point.clientY - cy) / (r.height / 2)));
        const mag = parsePerspective(el);
        s.rx = -ny * mag;
        s.ry = nx * mag;
        if (s.raf === null) s.raf = requestAnimationFrame(() => apply(el));
    };

    const resetEl = el => {
        const s = state.get(el);
        if (s.disableTransTimer) { clearTimeout(s.disableTransTimer); s.disableTransTimer = null; }
        if (s.raf !== null) { cancelAnimationFrame(s.raf); s.raf = null; }
        s.rx = 0; s.ry = 0; s.active = false;
        scheduleTransition(el);
        apply(el);
    };

    const globalMove = e => {
        const point = e.touches ? e.touches[0] : e;
        if (!point) return;
        const top = document.elementFromPoint(point.clientX, point.clientY);
        const me = top && top.closest ? top.closest('.MouseEffect') : null;
        for (const el of nodes) {
            if (el === me) {
                const s = state.get(el);
                if (!s.active) { s.active = true; scheduleTransition(el); }
                computeFor(el, point);
            } else {
                const s = state.get(el);
                if (s.active) resetEl(el);
            }
        }
    };

    window.addEventListener('pointermove', globalMove);
    window.addEventListener('mousemove', globalMove);
    window.addEventListener('touchmove', globalMove, { passive: true });

    const endAll = () => nodes.forEach(el => { const s = state.get(el); if (s.active) resetEl(el); });
    window.addEventListener('pointerup', endAll);
    window.addEventListener('mouseup', endAll);
    window.addEventListener('touchend', endAll);
})();
</script>

	</head>
	<body>
		<slot />
	</body>
</html>